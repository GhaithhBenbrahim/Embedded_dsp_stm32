/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include "arm_math.h"
#include "clock.h"
#include "adc.h"
#include "signals.h"
#include "fir_filter.h"
#include "fifo.h"
#include "tim.h"

#define GPIODEN        (1U << 3)
#define PIN12          (1U << 12)
#define Green_LED_PIN  PIN12

#define INPUT_SIG_LEN RXFIFOSIZE + IMP_RESP2_LENGTH - 1

static void pseudo_dly(int dly);
static void clear_data_buffer(void);
static uint8_t read_fifo(rx_data_t *data_buff);

void calc_convolution(float32_t *sig_src_arr,
		              float32_t *sig_dest_arr,
					  float32_t *imp_response_arr,
                      uint32_t signal_length,
					  uint32_t impulse_length) ;

extern float LP_1HZ_2HZ8IMPULSE_RESPONSE[IMP_RESP_LENGTH] ;
extern float LP_1HZ_3HZ_IMPULSE_RESPONSE[IMP_RESP2_LENGTH];

/*Global Variables*/
uint32_t g_sensor_read ;

fir_filter_t lpf_fir;

float32_t fltr_sensor_value;

uint8_t g_fifo_full_flag = 0 ,g_process_flag ;

rx_data_t sensor_data_buffer[RXFIFOSIZE];

float32_t output_signal_arr[INPUT_SIG_LEN ];

float32_t g_sensor_data , g_fltr_data;

int main(void)
{
	/*Enable FPU : Enable CP10 and CP11 full access*/
	SCB->CPACR |= ((3UL << 10*2)) | ((3UL << 10*2));

	/*Configure clock tree*/
	clock_100Mhz_config();

	/*Enable background thread*/
	tim2_1hz_interrupt_init();

	/*Initialize ADC*/
	pa1_adc_init();
	/*start conversion*/
	start_conversion();

	/*Initialize fir filter*/
	//fir_fiter_init(&lpf_fir ,LP_1HZ_3HZ_IMPULSE_RESPONSE, IMP_RESP2_LENGTH);

	//Initialize the FIFO
	rx_fifo_init();

	while(1)
	{
		g_sensor_read = adc_read();
		/*If g_prcess_flag is set to 1 , do dsp processing*/
		if(g_process_flag)
		{
			/*Reset data buffer*/
			clear_data_buffer();

			/*wait until entire batch is collected from adc*/
			//while(g_fifo_full_flag == 1){}
			/*Read fifo content into data buffer*/
			for(int i = 0 ; i < RXFIFOSIZE  ; i++)
			{
				/*wait until entire batch is collected from adc*/
				while(g_fifo_full_flag == 1){}

				/*read data into data buff*/
				g_fifo_full_flag = read_fifo(sensor_data_buffer +i);

			}

			/*Perform digital signal processing*/
			calc_convolution((float32_t *)sensor_data_buffer,
					         (float32_t *)output_signal_arr,
				        	 (float32_t *)LP_1HZ_3HZ_IMPULSE_RESPONSE,
			                 (uint32_t) RXFIFOSIZE,
						     (uint32_t) IMP_RESP2_LENGTH);



			/*Reset g_pocess_flag to 0*/
			g_process_flag = 0;
		}


	}
}

static uint8_t read_fifo(rx_data_t *data_buff)
{
	__IO uint8_t rd_flag ;

	/*place fifo data into data_buff*/
	rd_flag = rx_fifo_get(data_buff);

	/*if fifo is empty then reset g_fifo_full_flag*/
	if(rd_flag == 0)
	{
		/*this will start the fifo put again*/
		g_fifo_full_flag = 1 ;
	}
	else
	{
		/*keep fifo full flaf null*/
		g_fifo_full_flag = 0 ;
	}
	return g_fifo_full_flag;

}

void calc_convolution(float32_t *sig_src_arr,
		              float32_t *sig_dest_arr,
					  float32_t *imp_response_arr,
                      uint32_t signal_length,
					  uint32_t impulse_length)
     {
        int i, j;
        for(i = 0; i < (signal_length + impulse_length) ; i++) {
            sig_dest_arr[i] = 0;
            }
        for(i = 0; i < signal_length; i++) {
            for(j = 0; j < impulse_length; j++) {
                sig_dest_arr[i + j] += sig_src_arr[i] * imp_response_arr[j];
            }


     }
    }

static void clear_data_buffer(void)
{
	for(int i =0 ; i < RXFIFOSIZE ; i++)
	{
		sensor_data_buffer[i] = 0;
	}


}

static void tim2_callback(void)
{
	/*Check if fifo is not full*/
	if(g_fifo_full_flag == 1)
	{
		g_fifo_full_flag = rx_fifo_put(adc_read());
	}
	else
	{
		g_process_flag = 1;
	}
}

void TIM2_IRQHandler(void)
{
	/*Clear update interrupt flag*/
	TIM2->SR &= ~SR_UIF;

	tim2_callback();
}

static void pseudo_dly(int dly)
{
	for(int i =0;i < dly;i++){}

}



